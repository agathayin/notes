### Inventory fee
#### costCase
The latest cost per case edited in Edit Inventory.   
When PO is comfirmed and feesMatched, inventory latestRawCost and costCase are automatically updated according to the price in the PO product list.


#### internalSKU costCase, latestRawCost, and qtyPerCase
See inventoriesProcessed


#### inventoriesProcessed
*/api/inventoriesProcessed?avgCost=true*  
Average Costs:  
SKU:  
```
averageCostPerCase: 
latest averageCost.averageCostPerCase | inventory.costCase
averageRawCostPerCase: 
latest averageCost.averageRawCostPerCase | latest averageCost.averageCostPerCase | inventory.costCase
```

Internal SKU:   
```
// last averageCost found:  
averageCostPerCase: latest averageCost.averageCostPerCase
averageRawCostPerCase: latest averageCost.averageRawCostPerCase | latest averageCost.averageCostPerCase

// last averageCost not found:  
totalCostSingleForAvg: SUM((child.averageCostPerCase / child.qtyPerCase) * child.totalQty)  
totalRawCostSingleForAvg: SUM((child.averageCostPerCase / child.qtyPerCase) * child.totalQty)  

averageCostPerCase: totalCostSingleForAvg / totalQtyCountForAvg * data.weightQtyPerCase  
averageRawCostPerCase = totalRawCostSingleForAvg / totalQtyCountForAvg * data.weightQtyPerCase  
```
Latest Costs (internalSKU):  
```
// find latest price log generated by PO
var latestUpdatedVSKU = _.find(priceLogs, (log) => iSKUArray.some(el => el.SKU == log.SKU) && log.purchase && log.purchase.poNumber);
if (!latestUpdatedVSKU) {
  // log not found. find the latest updated VSKU by comparing field called lastUpdate
  latestUpdatedVSKU = iSKUArray[0];
  for (let iSKUData of iSKUArray) {
    if (
      iSKUData.lastUpdate &&
      new Date(iSKUData.lastUpdate) <= new Date(latestUpdatedVSKU.lastUpdate)
    ) {
      latestUpdatedVSKU = iSKUData;
      latestUpdatedVSKU.latestQtyPerCase = latestUpdatedVSKU.qtyPerCase;
    }
  }
} else {
  // log Found
  const lastUpdate = latestUpdatedVSKU.createdAt;
  latestUpdatedVSKU.costCase = latestUpdatedVSKU.newCostCase;
  latestUpdatedVSKU.latestRawCost = latestUpdatedVSKU.newRawCostCase
    ? latestUpdatedVSKU.newRawCostCase
    : latestUpdatedVSKU.newCostCase;
  latestUpdatedVSKU.lastUpdate = lastUpdate.createdAt;
  // get qtyPerCase from PO
  let po = _.get(latestUpdatedVSKU, "purchase.id");
  po = _.find(purchases, ["_id", po]);
  if (po) {
    po = po.poList.find((el) => el.SKU == latestUpdatedVSKU.SKU);
    latestUpdatedVSKU.latestQtyPerCase = po.poQtyPerCase;
  } else {
    latestUpdatedVSKU.latestQtyPerCase = _.get(
      iSKUArray.find((el) => el.SKU == latestUpdatedVSKU.SKU),
      "qtyPerCase"
    );
  }
}

// Set data
iSKUArray[k].costCase = latestUpdatedVSKU.costCase;
iSKUArray[k].latestRawCost = latestUpdatedVSKU.latestRawCost;
iSKUArray[k].lastUpdate = latestUpdatedVSKU.lastUpdate;
iSKUArray[k].latestQtyPerCase = latestUpdatedVSKU.latestQtyPerCase;
iSKUArray[k]._doc.latestQtyPerCase = latestUpdatedVSKU.latestQtyPerCase;
if (latestUpdatedVSKU.purchase && latestUpdatedVSKU.purchase.poNumber) {
  iSKUArray[k]._doc.lastPurchase = {
    SKU: latestUpdatedVSKU.SKU,
    poNumber: latestUpdatedVSKU.purchase.poNumber,
    id: latestUpdatedVSKU.purchase.id
  };
}
```


### Purchase fee
#### shippingFee
Sum of all poList shippingFee  
```
shippingFee = SUM(product.shippingFee * product.poqty / product.poQtyPerCase);
```
#### dutyFee
Sum of all poList dutyFee  
```
dutyFee = SUM(product.dutyFee * product.poqty / product.poQtyPerCase);
```
#### additionalFee
Sum ov all poList additionalFee  
```
additionalFee = SUM(product.additionalFee * product.poqty / product.poQtyPerCase);
```
#### poList rawCostCase
Inventory costCase. It should be the same as the purchase invoice receipt (?).

#### poList costCase
total costCase for inventory. 
```
costCase = rawCostCase + shippingFee + dutyFee + additionalFee;
```
#### AverageCost according to purchase
Every StockIn triggers to generage averageCost for both VSKU and its internalSKU. The formula for averageCostPerCase and averageRawCostPerCase are the same.  
newCost will be the rawCostCase in the purchase poList. If StockIn is irrelevant to purchase, use inventory costCase (latest cost) instead.  
SKU:  
```
// doc means stock data. 
// doc.totalQtyBefore means the totalQty before StockIn.
// newAverageCost.oldCostPerCase means the latest averageCost. If there is no existing averageCost, use inventory costCase instead.
newAverageCost.oldQtyCase = doc.totalQtyBefore / doc.qtyPerCase;
newAverageCost.totalQtyCase = newAverageCost.oldQtyCase + newQtyCase;

newAverageCost.averageCostPerCase = ((newAverageCost.oldQtyCase * newAverageCost.oldCostPerCase) + (newCost * newQtyCase)) / newAverageCost.totalQtyCase;
```
Internal SKU:  
```
// generated everytime when certain SKU average changes
// a1,a2 means averageCost A, averageCost B, q1,q2 means their qty
newAverageCost.averageCostPerCase = (a1*q1+a2*q2)/(q1+q2)
```
