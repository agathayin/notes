## selling partner api (spapi) with node

required libs: 

aws4 = require('aws4'), xml2js = require('xml2js'), _ = require('lodash')

### get orders
1. get accessToken => 'x-amz-access-token'
2. get temporary credentials => 'Authorization', 'X-Amz-Security-Token'
3. get orders

#### get access token
access token expires in 1 hour
```
async function getToken() {
  let localToken = accessToken;
  if (localToken && localToken.data && localToken.expiresAt && new Date().getTime() < Number(localToken.expiresAt)) {
    return {
      result: localToken.data
    };
  } else {
    let url = 'https://api.amazon.com/auth/o2/token';
    let body = new URLSearchParams();
    body.append("grant_type", "refresh_token");
    body.append("client_id", clientID);
    body.append("refresh_token", refreshToken);
    body.append("client_secret", clientSecret);
    let response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: body
    })
    if (response) {
      if (response.ok) {
        response = await response.json();
        let localStorage = {
          expiresAt: new Date().getTime() + _.get(response, 'expires_in') ? Number(_.get(response, 'expires_in')) * 1000 : 1000 * 60 * 60 * 59,
          data: response.access_token
        }
        accessToken = localStorage;
        return {
          result: response.access_token
        };
      } else {
        accessToken = null;
        return {
          message: response.statusText
        }
      }
    } else {
      return {
        message: 'No response from spapi'
      }
    }
  }
}
```
#### get credentials
credentials return their expiration time. Use aws4 to generate Authorization. Use xml2js to transform the xml response into object.  
accessKeyId and secretAccessKey, and roleArn should share the same user.  
request generated by aws4 is can be directly used for https.request. If so, there is no need to keep the url. url = `https://${signedRequest.host}${signedRequest.path}`

```
async function getCredentials() {
  let localToken = credentials;
  if (localToken && localToken.SessionToken && localToken.Expiration && new Date() < new Date(localToken.Expiration)) {
    return localToken;
  } else {
    let url = `https://sts.amazonaws.com/?Version=2011-06-15&Action=AssumeRole&RoleSessionName=Test&RoleArn=${roleArn}&DurationSeconds=3600`;
    const params = {
      path: `/?Version=2011-06-15&Action=AssumeRole&RoleSessionName=Test&RoleArn=${roleArn}&DurationSeconds=3600`,
      method: 'GET',
      host: 'sts.amazonaws.com',
      region: region,
      service: 'sts',
    };
  
    let request = aws4.sign(params, {
      accessKeyId: accessKeyId,
      secretAccessKey: secretAccessKey,
      region: region
    });
    let resp = await fetch(url, request);
    if(resp && resp.ok){
      resp = await resp.text();
      resp = await xml2js.parseStringPromise(resp, {
        explicitArray: false
      });
      localToken = _.get(resp,'AssumeRoleResponse.AssumeRoleResult.Credentials');
      if(localToken){
        credentials = localToken;
        return localToken
      }else{
        return {message: "Cannot get credentials"}
      }
    }else{
      credentials = null;
      return {
        message: resp.statusText
      }
    }
  }
};
```
#### set request config
```
async function requestConfig(path, method, body) {
  let tempCreds = await getCredentials();
  if (tempCreds.message) {
    return {
      message: tempCreds.message
    }
  }
  const {
    AccessKeyId,
    SessionToken,
    SecretAccessKey,
  } = tempCreds;
  const host = amzUrl.substring(amzUrl.indexOf('://') + 3);
  let token = await getToken();
  if (token.result) {
    token = token.result;
  } else {
    return {
      message: token.message
    }
  }
  const params = {
    path: path,
    method: method,
    host: host,
    region: region,
    service: 'execute-api',
    headers: {
      'User-Agent': 'MyAmazonApp/1.0 (Language=JavaScript;)',
      'x-amz-access-token': token,
    },
  };
  if (body) {
    params.body = JSON.stringify(body);
    params.headers["Content-Type"] = "application/json"
  }

  return aws4.sign(params, {
    accessKeyId: AccessKeyId,
    secretAccessKey: SecretAccessKey,
    sessionToken: SessionToken,
    region: region
  });
}
```
#### get orders
Please notice that the accessKeyId, secretAccessKey, and sessionToken here all come from getCredentials (different from the id on user page).

```
async function getOrders(url) {
  let now = new Date();
  let createAfter = new Date(now.getTime() - 1000 * 60 * 60 * 24 * 2).toISOString();
  if (!url) {
    url = `/orders/v0/orders?MarketplaceIds=${marketplaceId}&CreatedAfter=${createAfter}&FulfillmentChannels=MFN`;
  }
  if (amzUrl.includes("sandbox")) {
    marketplaceId = "ATVPDKIKX0DER";
    createAfter = "TEST_CASE_200"
  }
  let signedRequest = await requestConfig(url, 'GET');
  let response = await fetch(`https://${signedRequest.host}${signedRequest.path}`, signedRequest);
  let data = [];
  if (response) {
    try {
      response = await response.json();
    } catch (err) {
      return {
        message: 'Cannot parse orders' + err
      }
    }


    if (response.errors) {
      return {
        message: response.errors.map(el => el.message).join('. '),
        errors: response.errors
      }
    } else if (response.payload && response.payload.Orders) {
      data.push(...response.payload.Orders);
      //Important: the while statement for NextToken haven't been tested
      while (response.payload.NextToken) {
        //next request
        let nextToken = encodeURIComponent(response.payload.NextToken);
        let nextUrl = `/orders/v0/orders?MarketplaceIds=${marketplaceId}&NextToken=${nextToken}`;
        let nextSignedRequest = await requestConfig(nextUrl, 'GET');
        response = await fetch(`https://${nextSignedRequest.host}${nextSignedRequest.path}`, nextSignedRequest);
        if (response && response.ok) {
          response = await response.json();
          if (response.payload && response.payload.Orders) {
            data.push(response.payload.Orders);
          }
        }
      }
      return data;
    } else {
      return {
        message: 'Cannot get orders from amz',
        errors: response
      }
    }
  } else {
    return {
      message: 'No response from orders'
    }
  }
}
```
getOrder with NextToken (untested version)  
Important: use encodeURIComponent to encode NextToken, or it will show error like `We could not decode your NextToken. Possible reasons include: a transmission error, improper quoting or a truncation problem`
```
...
}else if(response.payload && response.payload.Orders){
      let data = [];
      data.push(...response.payload.Orders);
      while (response.payload.NextToken) {
        //next request
        let nextToken = encodeURIComponent(response.payload.NextToken);
        let nextUrl = `/orders/v0/orders?MarketplaceIds=${marketplaceId}&NextToken=${nextToken}`;
        let nextSignedRequest = await requestConfig(nextUrl, 'GET');
        response = await fetch(`https://${nextSignedRequest.host}${nextSignedRequest.path}`, nextSignedRequest);
        if (response && response.ok) {
          response = await response.json();
          if (response.payload && response.payload.Orders) {
            data.push(response.payload.Orders);
          }
        }
      }
      return data;
    }
...
```

### update order trackings with feeds api
The file format I upload is text/tab-separated-values.  
Guide link: [Feeds API Use Case Guide](https://github.com/amzn/selling-partner-api-docs/blob/main/guides/en-US/use-case-guides/feeds-api-use-case-guide/feeds-api-use-case-guide_2021-06-30.md)
#### create feed document  
```
async function createFeedDocument() {
  let body = {
    contentType: "text/tab-separated-values; charset=UTF-8"
  }
  if (amzUrl.includes("sandbox")) {
    body = {
      contentType: "text/tab-separated-values; charset=UTF-8"
    }
  }
  let signedRequest = await requestConfig(`/feeds/2021-06-30/documents`, 'POST', body);
  let response = await fetch(amzUrl + '/feeds/2021-06-30/documents', signedRequest);
  if (response) response = await response.json();
  return response;
}
```
#### construct a feed
Use `Buffer.from(content, 'utf-8').toString()` to transform content into utf-8 file. Here the content I generated already fits the format.  
```
async function constructAFeed(data) {
  let header = ['order-id', 'order-item-id', 'quantity', 'ship-date', 'carrier-code', 'tracking-number', 'ship-method'].join("\t");
  let rows = data.flatMap(d => {
    return d.box.flatMap(box => {
      return box.content.flatMap(content => {
        let lineArray = [{{orderId}}, {{orderItemId}}, {{qty}}, new Date({{shipDate}}).toISOString().split('T')[0], {{carrier}}, {{box.tracking}}, {{service}}]
        return lineArray.join("\t")
      })
    })
  })
  let content = header + "\n" + rows.join("\n") + "\n";
  return content;
}
```
#### upload feed data
```
async function uploadFeedData(url, content) {
  fetch(url, {
    method: "PUT",
    headers: {
      "Content-Type": "text/tab-separated-values; charset=UTF-8"
    },
    body: content
  })
}
```
#### create a feed
```
async function createAFeed(inputFeedDocumentId) {
  let body = {
    feedType: "POST_FLAT_FILE_FULFILLMENT_DATA",
    marketplaceIds: [marketplaceId],
    inputFeedDocumentId: inputFeedDocumentId
  }
  if (amzUrl.includes("sandbox")) {
    body = {
      feedType: "POST_PRODUCT_DATA",
      marketplaceIds: ["ATVPDKIKX0DER", "A1F83G8C2ARO7P"],
      inputFeedDocumentId: "3d4e42b5-1d6e-44e8-a89c-2abfca0625bb"
    }
  }
  let signedRequest = await requestConfig(`/feeds/2021-06-30/feeds`, 'POST', body);
  let response = await fetch(amzUrl + '/feeds/2021-06-30/feeds', signedRequest);
  if (response) response = await response.json();
  return response;
}
```
#### function to call feeds api
```
async function shipOrders(req, res) {
  let orders = await getUnshippedSelffulfillments();
  if (orders.message) {
    return res.status(500).send({
      message: orders.message
    })
  }
  if (orders && !orders.length) {
    return res.status(500).send({
      message: 'No unshipped orders to update'
    })
  }
  let feedDoc = await createFeedDocument();
  if (!feedDoc || feedDoc.errors || !feedDoc.url || !feedDoc.feedDocumentId) {
    return res.status(500).send({
      message: "Failed to create feed documnets",
      errors: feedDoc.errors
    })
  }
  let {
    feedDocumentId,
    url
  } = feedDoc;
  let content = await constructAFeed(orders);
  await uploadFeedData(url, content);
  let feed = await createAFeed(feedDocumentId);
  if (!feed.feedId || feed.message) {
    return res.status(500).send({
      message: feed.message,
      errors: feed
    })
  } else if (feed.feedId) {
    console.log("spapi feed: " + feed.feedId + " feedDocumentId: " + feedDocumentId + " url: " + url);
    res.status(200).send({
      feedId: feed.feedId,
      orderId: orders.map(el => el.orderId)
    })
  }
}
```
